#!/usr/bin/env python

""" This script processes records generates a local HTML page for viewing results """

import os
import re
import sys
import time
import pickle
import signal
import ConfigParser
from time import strftime
from optparse import OptionParser

# Holds all the metric info.  This is a multi-level data structure with the following
# format:
#   <Host> -> {}
#             <Metric> -> {}
#                         time   = Last time metric ran
#                         status = Last status of metric
#                         history -> []
#                                    <full text of record>
#                                    <full text of record>
#                                    ...
#            <Metric2> -> {}
#                         ...
#  <Host2> -> {}
#             ...
STATE = {}

ALERTS = []
OPTIONS = None
CONSUMER_DONE = 0

class InvalidRecordError(Exception):
    """ Custom exception for a bad record format """
    pass


def main():
    initialize()
    load_state_file()
    process_files()
    generate_html_files()
    write_state_file()
    sys.exit(0)


def initialize():
    """ Check that environment is valid """

    usage = """usage: html-consumer
      --vdt-location <VDT directory>
      --output-dir <HTML directory>
      --max-history <Number of historical entries>
      --help | -h 
      --version
    """

    version = "html-consumer 4.0"
    description = "This script processes RSV records and generates an HTML status page."

    parser = OptionParser(usage=usage, description=description, version=version)
    parser.add_option("--vdt-location", dest="vdt_location", default=None,
                      help="Root directory of the OSG installation", metavar="DIR")
    parser.add_option("--output-dir", dest="output-dir", default=None,
                      help="Directory to store HTML output", metavar="DIR")
    parser.add_option("--max_history", dest="max_history", default=20, type="int",
                      help="Number of historical entries to store for each metric.", metavar="SIZE")
    parser.add_option("--record_trim_length", dest="record_trim_length", type="int", default=10000,
                      help="Size in bytes to trim each record.  Default=%default", metavar="LENGTH" )

    global OPTIONS
    (OPTIONS, args) = parser.parse_args()

    #
    # Validate VDT-LOCATION
    #
    if not OPTIONS.vdt_location:
        if "VDT_LOCATION" not in os.environ:
            die("ERROR: VDT_LOCATION must be set in the environment or passed on the command line.")
        else:
            OPTIONS.vdt_location = os.environ["VDT_LOCATION"]

    if not os.path.exists(OPTIONS.vdt_location):
        die("ERROR: VDT_LOCATION is set to a non-existent directory: '%s'" % OPTIONS.vdt_location)

    OPTIONS.rsv_location = os.path.join(OPTIONS.vdt_location, "osg-rsv")

    #
    # Open a file for logging all output.  If we print all output to STDOUT it will end up in
    # a file that Condor will overwrite every time this script executes, so we'll move it to
    # a more permanent log file and rotate it manually.
    #
    log_file = os.path.join(OPTIONS.rsv_location, "logs", "consumers", "html-consumer.output")
    OPTIONS.log = open(log_file, 'a')

    log("html-consumer initializing.")

    # Where records will be read from
    # This script will delete files from this directory, so it also needs write access.
    OPTIONS.records_dir = os.path.join(OPTIONS.rsv_location, "output", "html-consumer")
    if not os.access(OPTIONS.records_dir, os.F_OK):
        die("ERROR: Records directory does not exist '%s'" % OPTIONS.records_dir)
    if not os.access(OPTIONS.records_dir, os.R_OK):
        die("ERROR: Cannot read records directory '%s'" % OPTIONS.records_dir)
    if not os.access(OPTIONS.records_dir, os.W_OK):
        die("ERROR: Cannot write records directory '%s'" % OPTIONS.records_dir)

    # Catch some signals and exit gracefully if we get them
    signal.signal(signal.SIGINT, sigterm_handler)
    signal.signal(signal.SIGTERM, sigterm_handler)

    return


def get_state_file_path():
    """ Returns the path of the state file """
    return os.path.join(OPTIONS.rsv_location, "output", "html", "state.file")


def load_state_file():
    """ Process the HTML state file """

    global ALERTS
    state_file = get_state_file_path()

    if not os.path.exists(state_file):
        log("State file does not exist.")
        return

    try:
        state_file_fp = open(state_file, 'r')
    except IOError, err:
        # If we can't read/write to the state file we won't be able to save any
        # results, but we should still write an HTML page with the problem.
        msg = "Error trying to load state file - %s" % err
        log(msg)
        ALERTS.append(msg)
        return

    try:
        global STATE
        STATE = pickle.load(state_file_fp)
    except EOFError, err:
        # Should this be a warning?
        log("State file is empty")
    except pickle.UnpicklingError, err:
        msg = "Error loading state file - %s" % err
        log(msg)
        # We should assume nobody will ever read the log file.  Push all error
        # messages to the web page for higher visibility.
        ALERTS.append(msg)
        
    return


def write_state_file():
    """ Save the state back to disk """

    state_file = get_state_file_path()

    state_fp = open(state_file, 'w')
    pickle.dump(STATE, state_fp)
    state_fp.close()

    return


def process_files():
    """ Open the records directory and load each file """

    files = os.listdir(OPTIONS.records_dir)
    log("Processing %s files" % len(files))
    for filename in files:
        if CONSUMER_DONE == 1:
            break
        
        success = 0

        file = os.path.join(OPTIONS.records_dir, filename)
        fh = open(file, 'r')
        record = fh.read()
        fh.close()

        if not record or record.isspace():
            log("The record in %s is empty.  Removing file." % filename)
        else:
            try:
                process_record(record)
            except InvalidRecordError, err:
                log("Error processing record: %s\nFull record:\n%s" % (err, record))

        try:
            os.remove(file)
        except OSError, err:
            # If we cannot remove the files then we are going to process them again
            # So stop processing now to avoid duplicate data.
            die("ERROR: Failed to remove record '%s'.  Error: %s" % (file, err))

    return


def parse_wlcg_record(raw_record):
    """ Parse a record in WLCG format and return a dict with values.  Example of WLCG record:

    metricName: org.osg.general.ping-host
    metricType: status
    timestamp: 2010-08-21T17:47:08Z
    metricStatus: OK
    serviceType: OSG-CE
    serviceURI: osg-edu
    gatheredAt: vdt-itb.cs.wisc.edu
    summaryData: OK
    detailsData: Host osg-edu is alive and responding to pings!
    EOT

    Note: for local probe serviceURI and gatheredAt are replaced by hostName

    """

    record = {}

    # detailsData will always come last, and might be multiple lines
    # Keep state so that once we are in the detailsData section, we put the rest of the
    # lines into detailsData and return when we see EOT
    in_details_data = 0
    for line in raw_record.split('\n'):
        if not in_details_data:
            match = re.match("(\w+): (.+)$", line)
            if match:
                record[match.group(1)] = match.group(2)
                if match.group(1) == "detailsData":
                    in_details_data = 1
            else:
                raise InvalidRecordError("Invalid line:\n\t%s" % line)
        else:
            if re.match("EOT$", line):
                return record
            else:
                record["detailsData"] += line

    # If we reach this point, it means we did not see EOT.  So the record is invalid
    raise InvalidRecordError("'EOT' marker missing")


def process_record(raw_record):
    """ Process a record in WLCG format """

    record = parse_wlcg_record(raw_record)

    #
    # Check that we got the values we are expecting
    #
    for attribute in ("metricName", "metricType", "metricStatus", "timestamp", "serviceType",
                      "summaryData", "detailsData"):
        if attribute not in record:
            raise InvalidRecordError("Missing %s" % attribute)

    # We need to have either (hostName) or (serviceURI + gatheredAt)
    host = None
    if "serviceURI" in record and "gatheredAt" in record:
        host = record["serviceURI"]
    elif "hostName" in record:
        host = record["hostName"]
    else:
        raise InvalidRecordError("Missing either hostName or (serviceURI + gatheredAt)")


    #
    # Update the state
    #
    metric = record["metricName"]

    global STATE
    if host not in STATE:
        STATE[host] = {}

    # Set the top-level metric info
    STATE[host][metric] = {}
    STATE[host][metric]["time"]   = record["timestamp"]
    STATE[host][metric]["status"] = record["metricStatus"]

    # Add an item to the history.  We could either do a history based on the number
    # of records kept (for each metric) or based on an expiration date since the record
    # was generated.  I'm picking the easier approach for now of just keeping an absolute
    # number.
    trimmed_record = raw_record[:OPTIONS.record_trim_length]

    if "history" not in STATE[host][metric]:
        STATE[host][metric]["history"] = []
    
    STATE[host][metric]["history"].insert(0, trimmed_record)
    if len(STATE[host][metric]["history"]) > OPTIONS.max_history:
        STATE[host][metric]["history"] = STATE[host][metric]["history"][0:OPTIONS.max_history]

    return


def generate_html_files():
    """ Write out the top-level HTML file and any host-specific files """

    main_page = html_template()

    # Fill in the basics
    timestamp = strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    title = "OSG RSV Main Status - %s" % timestamp
    header = "OSG RSV Main Status :: %s" % timestamp
    main_page = re.sub("!!TITLE!!", title, main_page)
    main_page = re.sub("!!HEADER!!", header, main_page)

    # Add in any alerts
    alerts = ""
    for alert in ALERTS:
        alerts += "<p class=\"alert\">WARNING: %s\n" % alert

    main_page = re.sub("!!ALERTS!!", alerts, main_page)

    # Generate a table for each host
    tables = ""
    if len(STATE) == 0:
        tables = "<p>There is no data to display.</p>"
    else:
        for host in STATE.keys():
            generate_host_html(host, STATE[host])
            host_table = html_table_template()
            host_table = re.sub("!!HOSTNAME!!", host, host_table)
            rows = []
            for metric in sorted(STATE[host]):
                link = "%s.html#%s" % (host, metric)
                row = "<tr><td><a href='%s'>%s</a></td><td>%s</td><td>%s</td><td>%s</td>" %\
                      (link, metric, STATE[host][metric]["time"], "TODO", STATE[host][metric]["status"])
                rows.append(row)

            table = '\n'.join(rows)
            host_table = re.sub("!!ROWS!!", table, host_table)
            tables += host_table
        
    main_page = re.sub("!!TABLES!!", tables, main_page)

    # There is no data for the main HTML page.  This section is only used for the
    # host-specific pages
    main_page = re.sub("!!DATA!!", "", main_page)

    try:
        main_html_file = os.path.join(OPTIONS.rsv_location, "output", "html", "index.html")
        fp = open(main_html_file, 'w')
        fp.write(main_page)
        fp.close()
    except IOError, err:
        log("Error writing main HTML file '%s': %s" % (main_html_file, err))

    return


def generate_host_html(host, info):
    """ Create the host-specific HTML file """

    host_page = html_template()

    # Fill in the basics
    timestamp = strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    title = "OSG RSV Status - %s - %s" % (host, timestamp)
    header = "OSG RSV Status :: %s :: %s" % (host, timestamp)
    host_page = re.sub("!!TITLE!!", title, host_page)
    host_page = re.sub("!!HEADER!!", header, host_page)

    # Add in any alerts
    alerts = ""
    for alert in ALERTS:
        alerts += "<p class=\"alert\">WARNING: %s\n" % alert

    host_page = re.sub("!!ALERTS!!", alerts, host_page)

    # Generate a table for the host, and display each historical result
    table = ""
    data = ""
    if len(info) == 0:
        table = "<p>There is no data to display.</p>"
    else:
        host_table = html_table_template()
        host_table = re.sub("!!HOSTNAME!!", host, host_table)
        rows = []
        for metric in sorted(info):
            link = "#%s" % metric
            row = "<tr><td><a href='%s'>%s</a></td><td>%s</td><td>%s</td><td>%s</td>" %\
                  (link, metric, info[metric]["time"], "TODO", info[metric]["status"])
            rows.append(row)

            data += "<a name='%s'></a><h2>%s</h2>\n" % (metric, metric)
            for entry in info[metric]["history"]:
                data += "<pre>%s</pre>\n" % entry

        table = re.sub("!!ROWS!!", '\n'.join(rows), host_table)
        
    host_page = re.sub("!!TABLES!!", table, host_page)
    host_page = re.sub("!!DATA!!", data, host_page)

    try:
        host_html_file = os.path.join(OPTIONS.rsv_location, "output", "html", "%s.html" % host)
        fp = open(host_html_file, 'w')
        fp.write(host_page)
        fp.close()
    except IOError, err:
        log("Error writing main HTML file '%s': %s" % (host_html_file, err))

    return


def log(msg):
    """ Print a message with a timestamp """
    timestamp = strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    print "%s: %s" % (timestamp, msg)

    if OPTIONS.log:
        OPTIONS.log.write("%s: %s\n" % (timestamp, msg))
        

def die(msg):
    """ Print an error message and exit with a non-zero status """
    log(msg)
    sys.exit(1)


def sigterm_handler(signum, frame):
    """ The handler for SIGTERM and SIGKILL """
    log("Caught signal #%s.  Exiting after processing current record." % signum)
    global CONSUMER_DONE
    CONSUMER_DONE = 1
    return


def html_template():
    """ Returns the HTML template file """

    return """<html>
   <head>
      !!TITLE!!
      <style type='text/css'>
      <!--
      pre {
         margin-left: 1em;
         margin-right: 1em;
         padding: 0.5em;
         background-color: #f0f0f0;
         border: 1px solid black;
      }
      body { 
         color: black;
         background-color: white;
      }
      #links_table { border: 1px solid black; width: 100%; }
      a:link {background: none; color: #000000; text-decoration: underline}
      a:visited {background: none; color: #000000; text-decoration: underline}
      a:hover {background: #000000; color: #FFFFFF; text-decoration: underline}

      #ok { background-color: #8ae234; }
      #warning { background-color: #fce94f; }
      #critical { background-color: #ef2929; }
      #old { background-color: #e0ae8b; }
      #unknown { background-color: #eeeeec; }
      #missing { background-color: #000000; color: #bbbbbb; }

      .question { cursor:pointer; text-decoration:underline; }
      .visible { display: block }
      .invisible { display: none }

      p.alert { background-color: red }
      -->
      </style>

      </script>
   </head>

   <body>
     <table>
       <tr>
         <td><a href='http://www.opensciencegrid.org' title='Open Science Grid'><img src='http://vdt.cs.wisc.edu/pictures/osg_logo.gif' border='0'></a></td>
         <td align='center'>!!HEADER!!</td>
       </tr>
    </table>
    !!ALERTS!!
    <p><a href=\"#legend\">Explanation of colors</a>
    <p><a href='old.html'>Archived HTML pages</a>
    <p>
    !!TABLES!!
    !!DATA!!

   <p>&nbsp;<p><a name=\"legend\">Legend:</a>
   <table>
     <tr id=\"ok\"><td>The metric ran successfully</td></tr>
     <tr id=\"warning\"><td>The metric produced some warnings</td></tr>
     <tr id=\"critical\"><td>The metric failed</td></tr>
     <tr id=\"unknown\"><td>The metric produced an unknown result</td></tr>
     <tr id=\"old\"><td>The metric is enabled, but it has not run for 24 hours</td></tr>
     <tr id=\"missing\"><td>The metric is enabled, but there is no data available yet</td></tr>
   </table>
   </body>
</html>
"""

def html_table_template():
    """ Return the HTML table template """
    return """<p>
      <table id='links_table'>
         <tr colspan=4>!!HOSTNAME!!</tr>
         <tr>
            <th>Metric</th>
            <th>Last Executed</th>
            <th>Approximate Next Run Time</th>
            <th>Status</th>
         </tr>
         !!ROWS!!
      </table>
      """


main()
